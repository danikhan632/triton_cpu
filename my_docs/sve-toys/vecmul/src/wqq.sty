







sve	svbfloat16_t	svzip1[_bf16]	(svbfloat16_t op1, svbfloat16_t op2)	Vector manipulation / Zip elements
Description
Interleave elements from low halves of two inputs
Results
Zresult.H  result
This intrinsic compiles to the following instruction:
ZIP1 Zresult.H, Zop1.H, Zop2.H

Argument Preparation
op1  register: Zop1.H
op2  register: Zop2.H
Architectures
A64
Operation
Extract the lowest-indexed halves of op1 and op2 and interleave the elements, so that each low element of op1 is followed by the corresponding element of op2.






	sve	svbool_t	svwhilelt_b16[_s64]	(int64_t op1, int64_t op2)	Predication / Initialization / While counter meets condition (forward)
Description
While incrementing scalar is less than
Results
Presult.H  result
This intrinsic compiles to the following instruction:
WHILELT Presult.H, Xop1, Xop2

Argument Preparation
op1  register: Xop1
op2  register: Xop2
Architectures
A64
Operation
Return a predicate in which element i is active if, for all values j in the range [0, i], adding j to op1 gives a value that is less than op2. The sequence will therefore yield at least one false predicate element before the addition wraps.

The first type suffix indicates the number of bits in each predicate element. For example, a suffix of _b8 indicates that the predicate controls 8-bit data, so element i corresponds to bit i of the predicate. A suffix of _b16 indicates that the predicate controls 16-bit data, so element i corresponds to bit i×2 of the predicate. When an element has more than one predicate bit associated with it, only the lowest of those bits is ever true.

sve	uint64_t	svcnth	()	Vector length / Count elements
Description
Count the number of 16-bit elements in a vector
Results
Xresult  result
This intrinsic compiles to the following instruction:
CNTH Xresult, ALL

Argument Preparation
Architectures
A64
Operation
Return the number of 16-bit elements in a full vector.

The underlying instruction takes a constant multiplier in the range [1, 16], which compilers can use to optimize multiplications of the function's return value.




	sve	bool	svptest_first	(svbool_t pg, svbool_t op)	Predication / Testing
Description
Test whether the first active element is true
Architectures
A64
Operation
Return true if at least one element is active and if the first active element of op is true.

Although the function is named after the PTEST instruction, the compiler may be able to avoid an explicit PTEST by reusing flags from a previous instruction.

sve	svfloat16_t	svld1[_f16]	(svbool_t pg, const float16_t *base)	Load / Consecutive
Description
Unextended load
Results
Zresult.H  result
When base has the form &array[index], this intrinsic can use:
LD1H Zresult.H, Pg/Z, [Xarray, Xindex, LSL #1]

The general implementation is:
LD1H Zresult.H, Pg/Z, [Xbase, #0, MUL VL]

Argument Preparation
pg  register: Pg.H
base  register: Xbase
Architectures
A64
Operation
Return a vector in which each active element i contains base[i] and in which all other elements are zero. Do not access memory for inactive elements.



sve	void	svst1[_f16]	(svbool_t pg, float16_t *base, svfloat16_t data)	Store / Consecutive
Description
Non-truncating store
Results
When base has the form &array[index], this intrinsic can use:
ST1H Zdata.H, Pg, [Xarray, Xindex, LSL #1]

The general implementation is:
ST1H Zdata.H, Pg, [Xbase, #0, MUL VL]

Argument Preparation
pg  register: Pg.H
base  register: Xbase
data  register: Zdata.H
Architectures
A64
Operation
For each active element i, store data[i] to base[i]. Do not access memory for inactive elements.



sve	svfloat16_t	svmla_lane[_f16]	(svfloat16_t op1, svfloat16_t op2, svfloat16_t op3, uint64_t imm_index)	Vector arithmetic / Multiply-accumulate / Fused multiply-accumulate
Description
Multiply-add, addend first
Results
Zresult.H|Ztied1.H  result
When result and op1 are in the same register, this intrinsic compiles to:
FMLA Ztied1.H, Zop2.H, Zop3.H[imm_index]

When result is in a different register from the inputs, this intrinsic compiles to:
MOVPRFX Zresult, Zop1

FMLA Zresult.H, Zop2.H, Zop3.H[imm_index]

Argument Preparation
op1  register: Zop1.H|Ztied1.H
op2  register: Zop2.H
op3  register: Zop3.H
imm_index  minimum: 0; maximum: 7
Architectures
A64
Operation
Return a vector in which each element i contains the value:


op1[i] + op2[i] * op3[base + imm_index]
where base is the index of the first element in the same 128-bit quadword as i.

The multiplication and addition are fused, with no intermediate rounding after the multiplication.

Exceptions
Signaling NaNs trigger an IEEE Invalid exception but quiet NaNs do not. Multiplying an infinity by zero also triggers an IEEE Invalid exception, as does adding +∞ and -∞ together.









Description
Set predicate elements to true
Results
Presult.H  result
This intrinsic compiles to the following instruction:
PTRUE Presult.H, ALL

Argument Preparation
Architectures
A64
Operation
Return a predicate in which every element is true (one). Only the lowest bit of each element is set; the upper bits are always zero.





sve	svfloat16_t	svdup[_n]_f16	(float16_t op)	Vector manipulation / Set all lanes to the same value
Description
Broadcast a scalar value
Results
Zresult.H  result
When bitcast<int16_t>(op) is in range[1], this intrinsic can use:
DUP Zresult.H, #op

When op is an FP immediate[2], this intrinsic can use:
FDUP Zresult.H, #op

When op is in a GP register, the general implementation is:
DUP Zresult.H, Wop

When op is in an FP register, the general implementation is:
DUP Zresult.H, Zop.H[0]

Argument Preparation
op  register: Hop|Wop
Architectures
A64
Operation
Return a vector in which each element i contains op.

[1] This is true if the value is in the range [-128, 127] or is a multiple of 256 in the range [-32768, 32512]

[2] This is true if op is a floating-point immediate value expressable as ±n×2r, where n and r are integers such that 16 ≤ n ≤ 31 and -7 ≤ r ≤ 0. In other words, this instruction requires op to have a normalized binary floating-point encoding with a sign bit, a 3-bit exponent, and a 4-bit fractional part.





ALL INSTRCUTIONS USED:
ZIP1, ZIP2 (vectors)
Interleave elements from two half vectors

Interleave alternating elements from the lowest or highest halves of the first and second source vectors and place in elements of the destination vector. This instruction is unpredicated.

The 128-bit element variant requires that the Effective SVE vector length is at least 256 bits. ID_AA64ZFR0_EL1.F64MM indicates whether the 128-bit element variant is implemented. The 128-bit element variant is illegal when executed in Streaming SVE mode, unless FEAT_SME_FA64 is implemented and enabled.

It has encodings from 4 classes: High halves , High halves (quadwords) , Low halves and Low halves (quadwords)

High halves
31	30	29	28	27	26	25	24	23	22	21	20	19	18	17	16	15	14	13	12	11	10	9	8	7	6	5	4	3	2	1	0
0	0	0	0	0	1	0	1	size	1	Zm	0	1	1	0	0	1	Zn	Zd
H		
ZIP2 <Zd>.<T>, <Zn>.<T>, <Zm>.<T>


if !HaveSVE() && !HaveSME() then UNDEFINED;
constant integer esize = 8 << UInt(size);
integer n = UInt(Zn);
integer m = UInt(Zm);
integer d = UInt(Zd);
integer part = 1;
High halves (quadwords)
(FEAT_F64MM)
31	30	29	28	27	26	25	24	23	22	21	20	19	18	17	16	15	14	13	12	11	10	9	8	7	6	5	4	3	2	1	0
0	0	0	0	0	1	0	1	1	0	1	Zm	0	0	0	0	0	1	Zn	Zd
H		
ZIP2 <Zd>.Q, <Zn>.Q, <Zm>.Q


if !HaveSVE() || !HaveSVEFP64MatMulExt() then UNDEFINED;
constant integer esize = 128;
integer n = UInt(Zn);
integer m = UInt(Zm);
integer d = UInt(Zd);
integer part = 1;
Low halves
31	30	29	28	27	26	25	24	23	22	21	20	19	18	17	16	15	14	13	12	11	10	9	8	7	6	5	4	3	2	1	0
0	0	0	0	0	1	0	1	size	1	Zm	0	1	1	0	0	0	Zn	Zd
H		
ZIP1 <Zd>.<T>, <Zn>.<T>, <Zm>.<T>


if !HaveSVE() && !HaveSME() then UNDEFINED;
constant integer esize = 8 << UInt(size);
integer n = UInt(Zn);
integer m = UInt(Zm);
integer d = UInt(Zd);
integer part = 0;
Low halves (quadwords)
(FEAT_F64MM)
31	30	29	28	27	26	25	24	23	22	21	20	19	18	17	16	15	14	13	12	11	10	9	8	7	6	5	4	3	2	1	0
0	0	0	0	0	1	0	1	1	0	1	Zm	0	0	0	0	0	0	Zn	Zd
H		
ZIP1 <Zd>.Q, <Zn>.Q, <Zm>.Q


if !HaveSVE() || !HaveSVEFP64MatMulExt() then UNDEFINED;
constant integer esize = 128;
integer n = UInt(Zn);
integer m = UInt(Zm);
integer d = UInt(Zd);
integer part = 0;
Assembler Symbols
<Zd>	
Is the name of the destination scalable vector register, encoded in the "Zd" field.

<T>	
Is the size specifier, encoded in size:

size	<T>
00	B
01	H
10	S
11	D
<Zn>	
Is the name of the first source scalable vector register, encoded in the "Zn" field.

<Zm>	
Is the name of the second source scalable vector register, encoded in the "Zm" field.

Operation

if esize < 128 then CheckSVEEnabled(); else CheckNonStreamingSVEEnabled();
constant integer VL = CurrentVL;
if VL < esize * 2 then UNDEFINED;
constant integer pairs = VL DIV (esize * 2);
bits(VL) operand1 = Z[n, VL];
bits(VL) operand2 = Z[m, VL];
bits(VL) result = Zeros(VL);

integer base = part * pairs;
for p = 0 to pairs-1
    Elem[result, 2*p+0, esize] = Elem[operand1, base+p, esize];
    Elem[result, 2*p+1, esize] = Elem[operand2, base+p, esize];

Z[d, VL] = result;
Operational information
If FEAT_SVE2 is implemented or FEAT_SME is implemented, then if PSTATE.DIT is 1:

The execution time of this instruction is independent of:
The values of the data supplied in any of its registers.
The values of the NZCV flags.
The response of this instruction to asynchronous exceptions does not vary based on:
The values of the data supplied in any of its registers.
The values of the NZCV flags.


LD1H (scalar plus immediate, consecutive registers)
Contiguous load of halfwords to multiple consecutive vectors (immediate index)

Contiguous load of unsigned halfwords to elements of two or four consecutive vector registers from the memory address generated by a 64-bit scalar base and immediate index which is multiplied by the vector's in-memory size, irrespective of predication, and added to the base address.

Inactive elements will not cause a read from Device memory or signal a fault, and are set to zero in the destination vector.

It has encodings from 2 classes: Two registers and Four registers

Two registers
(FEAT_SVE2p1)
31	30	29	28	27	26	25	24	23	22	21	20	19	18	17	16	15	14	13	12	11	10	9	8	7	6	5	4	3	2	1	0
1	0	1	0	0	0	0	0	0	1	0	0	imm4	0	0	1	PNg	Rn	Zt	0
msz<1>	msz<0>				N
LD1H { <Zt1>.H-<Zt2>.H }, <PNg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]


if !HaveSME2() && !HaveSVE2p1() then UNDEFINED;
integer n = UInt(Rn);
integer g = UInt('1':PNg);
constant integer nreg = 2;
integer t = UInt(Zt:'0');
constant integer esize = 16;
integer offset = SInt(imm4);
Four registers
(FEAT_SVE2p1)
31	30	29	28	27	26	25	24	23	22	21	20	19	18	17	16	15	14	13	12	11	10	9	8	7	6	5	4	3	2	1	0
1	0	1	0	0	0	0	0	0	1	0	0	imm4	1	0	1	PNg	Rn	Zt	0	0
msz<1>	msz<0>					N
LD1H { <Zt1>.H-<Zt4>.H }, <PNg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]


if !HaveSME2() && !HaveSVE2p1() then UNDEFINED;
integer n = UInt(Rn);
integer g = UInt('1':PNg);
constant integer nreg = 4;
integer t = UInt(Zt:'00');
constant integer esize = 16;
integer offset = SInt(imm4);
Assembler Symbols
<Zt1>	
For the two registers variant: is the name of the first scalable vector register to be transferred, encoded as "Zt" times 2.

For the four registers variant: is the name of the first scalable vector register to be transferred, encoded as "Zt" times 4.

<Zt4>	
Is the name of the fourth scalable vector register to be transferred, encoded as "Zt" times 4 plus 3.

<Zt2>	
Is the name of the second scalable vector register to be transferred, encoded as "Zt" times 2 plus 1.

<PNg>	
Is the name of the governing scalable predicate register PN8-PN15, with predicate-as-counter encoding, encoded in the "PNg" field.

<Xn|SP>	
Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.

<imm>	
For the two registers variant: is the optional signed immediate vector offset, a multiple of 2 in the range -16 to 14, defaulting to 0, encoded in the "imm4" field.

For the four registers variant: is the optional signed immediate vector offset, a multiple of 4 in the range -32 to 28, defaulting to 0, encoded in the "imm4" field.

Operation

if HaveSVE2p1() then CheckSVEEnabled(); else CheckStreamingSVEEnabled();
constant integer VL = CurrentVL;
constant integer PL = VL DIV 8;
constant integer elements = VL DIV esize;
constant integer mbytes = esize DIV 8;
bits(64) base;
bits(PL) pred = P[g, PL];
bits(PL * nreg) mask = CounterToPredicate(pred<15:0>, PL * nreg);
array [0..3] of bits(VL) values;
boolean contiguous = TRUE;
boolean nontemporal = FALSE;
boolean tagchecked = n != 31;
AccessDescriptor accdesc = CreateAccDescSVE(MemOp_LOAD, nontemporal, contiguous, tagchecked);

if !AnyActiveElement(mask, esize) then
    if n == 31 && ConstrainUnpredictableBool(Unpredictable_CHECKSPNONEACTIVE) then
        CheckSPAlignment();
else
    if n == 31 then CheckSPAlignment();
    base = if n == 31 then SP[] else X[n, 64];

for r = 0 to nreg-1
    for e = 0 to elements-1
        if ActivePredicateElement(mask, r * elements + e, esize) then
            integer eoff = offset * nreg * elements + r * elements + e;
            bits(64) addr = GenerateAddress(base, eoff * mbytes, accdesc);
            Elem[values[r], e, esize] = Mem[addr, mbytes, accdesc];
        else
            Elem[values[r], e, esize] = Zeros(esize);

for r = 0 to nreg-1
    Z[t+r, VL] = values[r];
Operational information
If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored when its governing predicate register contains the same value for each execution.



sve	void	svst1_vnum[_bf16]	(svbool_t pg, bfloat16_t *base, int64_t vnum, svbfloat16_t data)	Store / Consecutive
Description
Non-truncating store
Results
When vnum is in the range [-8, 7], this intrinsic can use:
ST1H Zdata.H, Pg, [Xbase, #vnum, MUL VL]

The general implementation is:
ST1H Zdata.H, Pg, [Xbase, Xindex, LSL #1]

Argument Preparation
pg  register: Pg.H
base  register: Xbase
data  register: Zdata.H
vnum * svcnth()  register: Xindex
Architectures
A64
Operation
For each active element i, store data[i] to base[n * vnum + i], where n is the number of elements in data. Do not access memory for inactive elements.

OPER DOCUMENTATION
We could not find that page in the latest version, so we have taken you to the first page instead
Previous Section
Next Section





ST1H (vector plus immediate)
Scatter store halfwords from a vector (immediate index)

Scatter store of halfwords from the active elements of a vector register to the memory addresses generated by a vector base plus immediate index. The index is a multiple of 2 in the range 0 to 62. Inactive elements are not written to memory.

This instruction is illegal when executed in Streaming SVE mode, unless FEAT_SME_FA64 is implemented and enabled.

It has encodings from 2 classes: 32-bit element and 64-bit element

32-bit element
31	30	29	28	27	26	25	24	23	22	21	20	19	18	17	16	15	14	13	12	11	10	9	8	7	6	5	4	3	2	1	0
1	1	1	0	0	1	0	0	1	1	1	imm5	1	0	1	Pg	Zn	Zt
msz<1>	msz<0>						
ST1H { <Zt>.S }, <Pg>, [<Zn>.S{, #<imm>}]


if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Zn);
integer g = UInt(Pg);
constant integer esize = 32;
constant integer msize = 16;
integer offset = UInt(imm5);
64-bit element
31	30	29	28	27	26	25	24	23	22	21	20	19	18	17	16	15	14	13	12	11	10	9	8	7	6	5	4	3	2	1	0
1	1	1	0	0	1	0	0	1	1	0	imm5	1	0	1	Pg	Zn	Zt
msz<1>	msz<0>						
ST1H { <Zt>.D }, <Pg>, [<Zn>.D{, #<imm>}]


if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Zn);
integer g = UInt(Pg);
constant integer esize = 64;
constant integer msize = 16;
integer offset = UInt(imm5);
Assembler Symbols
<Zt>	
Is the name of the scalable vector register to be transferred, encoded in the "Zt" field.

<Pg>	
Is the name of the governing scalable predicate register P0-P7, encoded in the "Pg" field.

<Zn>	
Is the name of the base scalable vector register, encoded in the "Zn" field.

<imm>	
Is the optional unsigned immediate byte offset, a multiple of 2 in the range 0 to 62, defaulting to 0, encoded in the "imm5" field.

Operation

CheckNonStreamingSVEEnabled();
constant integer VL = CurrentVL;
constant integer PL = VL DIV 8;
constant integer elements = VL DIV esize;
bits(PL) mask = P[g, PL];
bits(VL) base;
bits(VL) src;
constant integer mbytes = msize DIV 8;
boolean contiguous = FALSE;
boolean nontemporal = FALSE;
boolean tagchecked = TRUE;
AccessDescriptor accdesc = CreateAccDescSVE(MemOp_STORE, nontemporal, contiguous, tagchecked);

if AnyActiveElement(mask, esize) then
    base = Z[n, VL];
    src = Z[t, VL];

for e = 0 to elements-1
    if ActivePredicateElement(mask, e, esize) then
        bits(64) baddr = ZeroExtend(Elem[base, e, esize], 64);
        bits(64) addr = GenerateAddress(baddr, offset * mbytes, accdesc);
        Mem[addr, mbytes, accdesc] = Elem[src, e, esize]<msize-1:0>;
Operational information
If FEAT_SVE2 is implemented or FEAT_SME is implemented, then if PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored when its governing predicate register contains the same value for each execution.